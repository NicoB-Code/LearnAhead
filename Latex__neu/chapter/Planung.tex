\section{Planungsphase}
\label{Planung}

\subsection{Lastenheft}

\subsubsection{Allgemeine Beschreibung}
Eine mobile LernApp, mit der Möglichkeit Lerninhalte zusammenzufassen und von diesen in Abhängigkeit Tests zu erstellen.
Von den eingetragenen Lerninhalten können dann Tests erstellt werden, welche aus verschiedenen Fragen bestehen.
Es besteht die Möglichkeit die Inhalt nach Kategorien zu gruppieren und Lernzielen zu zuweisen.
Mit diesen Lernzielen wird dem User dann ein empfohlener Lernplan erstellt.

\subsubsection{Anforderungen}
\begin{itemize}
    \item Lerninhalte zusammenfassen
    \item Tests erstellen
    \item Lernkategorien
    \item Auf Android im Play Store verfügbar
    \item Lernziele und dazugehörigen automatisch erstellten Lernplan
    \item User-Profil mit Benutzername und Kennwort
\end{itemize}

\subsubsection{Fachliches Umfeld}
\begin{itemize}
    \item Plattformabhängig mit Android Studio
    \item Mobile Lösung
    \item Datenbank
    \item IT-Security
    \item DSGVO
\end{itemize}

\subsubsection{Ausblick}
Bei erfolgreichen Entwicklungsergebnissen soll die Lösung in Betrieb genommen und der Öffentlichkeit, per Play Store, zur Verfügung gestellt werden.

\subsubsection{Erweiterungsmöglichkeiten (optional)}
\begin{itemize}
    \item Importieren und Exportieren von Lerninhalten auf WhatsApp oder Ähnlichem
\end{itemize}


\subsection{Arbeitspaketplan}
\label{sec:arbeitspaketplan}
Der Arbeitspaketplan bezeichnet die Aufzählung jedes Arbeitspakets auf Basis des Lastenhefts. \newline Ein Arbeitspaket wird durch folgendes definiert: 
\begin{itemize}
    \item Ein definiertes Ergebnis (was soll in diesem Arbeitspaket erreicht werden)
    \item Der zeitliche Aufwand des Arbeitspakets
    \item Die Vorbedingungen, die beim Bearbeiten zu beachten sind
    \item Die Dauer
\end{itemize}


\noindent
Um die Arbeitspakete grafisch aufbereitet darstellen zu können, werden diese in die Anwendung \href{https://studienarbeitlernapp.atlassian.net/jira/software/projects/LER/boards/1}{\underline{Jira}}\footnote{\href{https://studienarbeitlernapp.atlassian.net/jira/software/projects/LER/boards/1}{https://studienarbeitlernapp.atlassian.net/jira/software/projects/LER/boards/1}} ausgelagert.
Hier wird der Arbeitspaketplan als Unterteilung der einzelnen Epics in User Stories dargestellt.
Erledigte Epics und User Stories sind dabei unter dem Reiter \gqq{Fertig} einsehbar.
In den einzelnen User Stories wird ein definiertes Ergebnis aus Sicht des Nutzers beschrieben.
Der zeitliche Aufwand der einzelnen Arbeitspakete ergibt sich aus der Summe der Dauer der zugewiesenen Tasks. 
In Kombination mit Scrum werden dabei vor Beginn des jeweiligen Sprints die einzelnen Tasks geschätzt und auf einen festen Arbeitsaufwand festgelegt. 

Im Laufe des Sprints werden dann die zugewiesenen Stunden von den zugewiesenen Bearbeitern abgebaut und im jeweiligen Task aktualisiert.
Ist der Task beendet, so wird er mit \gqq{Done} markiert und besitzt somit keinen Arbeitsaufwand mehr.

Vorbedingungen, sowie die festgelegte Dauer für die Bearbeitung eines Arbeitspaketes werden durch die Sprints definiert. 
Durch Aufteilen der Tasks in verschiedene, nacheinander ablaufende Sprints, können Vorbedingungen durch Einteilung in einen vorangehenden Sprint gesetzt werden.
Darüber hinaus können den einzelnen Tasks Prioritäten zwischen eins und vier zugeordnet werden, was eine Hierarchie innerhalb eines Sprints ermöglicht.
Zusätzlich limitiert die Dauer des Sprints die Bearbeitungszeit für den jeweiligen Task.

\newpage
\subsection{Vorrausichtlicher Zeitplan}
Zu Beginn der Studienarbeit wurde ein vorrausichtlicher Zeitplan erstellt, der die einzelnen Meilensteine und deren Fertigstellungstermine beinhaltet. Dieser Zeitplan ist in Tabelle \ref{tab:VorrausichtlicherZeitplan} unten zu sehen.
\begin{table}[H]
  \centering
  \resizebox{\columnwidth}{!}{%
  \begin{tabular}{l|l|l}
  \multicolumn{1}{c|}{\textbf{Meilenstein}} &
    \multicolumn{1}{c|}{\textbf{Abgeschlossen bis}} &
    \multicolumn{1}{c}{\textbf{Beschreibung}} \\ \hline
  Literaturrecherche &
    \begin{tabular}[c]{@{}l@{}}KW 5 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Das Durchführen einer umfangreichen Literaturrecherche\\ auf Basis von wissenschaftlichen Dokumenten.\end{tabular} \\ \hline
  Use-Case-Erstellung &
    \begin{tabular}[c]{@{}l@{}}KW 45 2022\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Identifizierung und Dokumentation der \\ Hauptfunktionalitäten und Anwendungsfälle der Lern-App.\end{tabular} \\ \hline
  UI-Konzept &
    \begin{tabular}[c]{@{}l@{}}KW 52 2022\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Entwicklung eines visuellen Konzepts für die \\ Benutzeroberfläche (UI) der Lern-App.\end{tabular} \\ \hline
  Datenbank-Konzept &
    \begin{tabular}[c]{@{}l@{}}KW 4 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Design und Auswahl des Datenbanksystems, die für die \\ App benötigt wird.\end{tabular} \\ \hline
  Architektur-Konzept &
    \begin{tabular}[c]{@{}l@{}}KW 6 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Realisierung einer Code-Architektur und Auswahl  \\ verschiedener Komponenten sowie Framekworks, \\ die in der App verwendet werden.\end{tabular} \\ \hline
  Architektur-Prototyp &
    \begin{tabular}[c]{@{}l@{}}KW 8 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Erstellung eines ersten Prototypen \\  der die vorgeschlagene Architektur implementiert.\end{tabular} \\ \hline
  Login / Registrierung &
    \begin{tabular}[c]{@{}l@{}}KW 11 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Implementierung der Funktionen für Anmeldung, \\ Registrierung und Passwortwiederherstellung.\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Lernkategorien \& \\ Lernziele\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}KW 13 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Implementierung der Funktion zum Erstellen sowie Verwalten\\  von Lernkategorien und -zielen.\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Erstellung von Fragen \\ und Tests\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}KW 18 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Implementierung der Funktion zum Erstellen sowie Verwalten\\  von Fragen und Tests.\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Erstellung von \\ Zusammenfassungen\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}KW 24 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Implementierung der Funktion zum Erstellen sowie  \\ Verwalten von Zusammenfassungen von Lernkategorien.\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Optimale Pausenberechnung \\ realisieren\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}KW 26 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Erstellung eines Algorithmus, welcher den Nutzer die  \\ optimale Pause vorschlägt sowie errinert.\end{tabular} \\ \hline
  \begin{tabular}[c]{@{}l@{}}Optimale Lernplan \\ generieren\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}KW 27 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Erstellung eines optimalen Lernplans auf Basis der Lernziele.\\\end{tabular} \\ \hline
  Durchführen von Tests &
    \begin{tabular}[c]{@{}l@{}}KW 28 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Durchführung von umfassenden Tests, um die Qualität, \\ Funktionalität und Stabilität der App sicherzustellen.\end{tabular} \\ \hline
  Bugs beheben &
    \begin{tabular}[c]{@{}l@{}}KW 29 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Behebung von Fehlern und Problemen in der App.\end{tabular} \\ \hline
  Dokumentation &
    \begin{tabular}[c]{@{}l@{}}KW 29 2023\end{tabular} &
    \begin{tabular}[c]{@{}l@{}}Erstellung einer wissenschaftlichen Arbeit, die das Vorgehen, \\ Funktionen, die Implementierung sowie die Verwendung \\ der App begründet.\end{tabular}
  \end{tabular}%
  }
  \caption{Vorrausichtlicher Entwurf eines Zeitplan für die Entwicklung der Lern-App.}
  \label{tab:VorrausichtlicherZeitplan}
  \end{table}

\newpage
\subsection{Qualitätsmanagement Maßnahmen}
Die Qualität der Lern-App wird durch \gqq{Unit-Tests} sowie von externen Probanden durch festgelegte Tests ermittelt. Die Unit-Tests werden von den Entwicklern der App durchgeführt, um die Qualität der einzelnen Komponenten im Backzu gewährleisten. Nach Abschluss der Implementierungsphase wird eine geschlossene Beta durchgeführt, bei der die Tester informiert werden, welche Funktionen getestet werden sollen. Folgende Funktionalitäten sollen überprüft werden:
\begin{itemize}
  \item Anmeldung
  \item Registrierung
  \item Passwortwiederherstellung
  \item Erstellen von Lernkategorien
  \item Erstellen von Lernzielen
  \item Erstellen von Fragen
  \item Erstellen von Tests
  \item Erstellen von Zusammenfassungen
  \item Generierung eines optimalen Lernplans
  \item Berechnung der optimalen Pausen
\end{itemize}
\noindent
Zu jeder Funktionalität soll der Tester eine kurze textuelle Beschreibung abgeben, welche positiven sowie negativen Aspekte er festgestellt hat. Aufgrund der Rückmeldungen kann die App weiter verbessert und Fehler behoben werden.
Zusätzlich sollen die Tests auf unterschiedlichen Android-Geräten durchgeführt werden, um die Kompatibilität der App zu gewährleisten. 
\subsection{Konfigurationsmanagement Maßnahmen}
Die agile Planung im erweitertem Scrum erfolgt in Jira, hier ist der Backlog angelegt, in welchem die Sprint-Planung erfolgt. Meetings werden auf Discord durchgeführt. Die Dokumentation wird mit \LaTeX  geschrieben.\newline
Die Versions- und Releaseverwaltung erfolgt in einem GitHub Repository unter dem Git-Branching-Modell Gitflow. Gitflow sieht zwei Branches vor um den Verlauf des Projekts aufzuzeichnen. Der main-Branch enthält den offiziellen Release-Verlauf und der develop-Branch dient als Integrations-Branch für Features. Der develop-Branch enthält den kompletten Versionsverlauf des Projekts, während der main-Branch eine verkürzte Version enthält.\newline
Jedes neue Feature sollte sich auf seinem eigenen Branch befinden, der zu \\ Sicherungs-/Zusammenarbeitszwecken zum zentralen Repository gepusht werden kann. Ein neuer feature-Branch  wird aus dem develop-branch gemerget. Wenn ein Feature fertig ist, wird es zurück in den develop-Branch gemergt. Features sollten niemals direkt mit dem main-Branch interagieren.\newline
Wenn der develop-Branch genügend Features für ein Release enthält, wird vom develop-Branch ein release-Branch geforkt. Damit beginnt der neue Release-Zyklus. In diesem Branch sollten ab diesem Punkt keine neuen Features mehr hinzugefügt werden, sondern nur Bugfixes und ähnliche Release-orientierte Änderungen. Ist er zur Auslieferung bereit, wird der release-Branch in den main-Branch gemergt und mit einer Versionsnummer getaggt. Zusätzlich wird der release-Branch in den develop-Branch gemerged. \newline
Maintenance- bzw. hotfix-Branches eignen sich für schnelle Patches von Produktions-Releases. Sie werden aus dem main-Branch geforkt. Sobald der Bugfix abgeschlossen ist, wird er sowohl in den main- als auch in den develop-Branch (oder den aktuellen release-Branch) gemergt.
\subsection{Evaluierung der Plattformen und Programmiersprachen für die App-Entwicklung
}
Die Lernapp LearnAhead wird als Android-App umgesetzt, weil die Entwickler selbst nur Android-Geräte zur Verfügung haben. Zusätzlich kommt noch hinzu, dass eine Apple-Entwickler-Lizenz ca. 99\$ pro Jahr kostet \cite{noauthor_registrierung_nodate}. Die Kosten für die Veröffentlichung einer Android-App beträgt hierbei nur einmalig 25\$ \cite {appsoluts_unterschied_2016}. Daraus ergibt sich, dass die Entwicklung einer Android-App deutlich günstiger ist. \\

\noindent
Für die Entwicklung der App wird die Programmiersprache Kotlin verwendet. Kotlin ist eine moderne Programmiersprache, die von JetBrains entwickelt wurde. Sie ist eine statisch typisierte Open-Source-Programmiersprache, die auf der Java Virtual Machine (JVM) ausgeführt wird.Kotlin ist eine moderne Programmiersprache, die viele Vorteile gegenüber Java bietet. Kotlin ist kompakter als Java, da es weniger Boilerplate-Code benötigt. Die Stärken liegen hierbei auf der einfachen und kompakten Syntax von Kotlin. Dies reduziert auf der einen Seite den Programmieraufwand, um die gleiche Funktionalität wie in Java zu erreichen. Dies macht den Code leichter lesbar und verständlicher. Zusätzlich existiert das größte Problem der NullPointerExeption in Kotlin nicht. \cite {bollhoff_kotlin_2022}
